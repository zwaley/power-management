# 拓扑图功能开发计划

## 项目现状分析

### 当前技术架构

- **后端**: FastAPI + SQLite + NetworkX
- **前端**: Bootstrap 5 + 原生JavaScript
- **已有功能**: 设备管理、连接管理、Excel导入、基础统计
- **数据模型**: Device、Connection、LifecycleRule
- **图形库**: 已集成vis.js (在graph.html中)

### 现有优势

1. 项目架构简洁，易于扩展
2. 已有基础的设备和连接数据模型
3. 已集成NetworkX图论库
4. 已有vis.js的基础集成
5. FastAPI提供良好的API扩展能力

## MVP功能范围定义

### 核心目标

基于现有架构，实现**设备级和端口级拓扑图可视化**，重点关注实用性而非复杂性。端口级拓扑图作为核心功能，提供精确的连接关系展示；设备级拓扑图提供宏观的系统架构视图。

### MVP功能清单

#### 第一阶段：基础拓扑显示 (2-3周)

1. **端口级拓扑图**（优先开发）
   
   - 基于现有Connection表的source_port和target_port字段显示端口连接
   - 端口信息显示（熔丝、空开规格等）
   - 端口搜索和筛选功能
   - 端口状态可视化（已连接/空闲）
   - **总线式端口显示方案**（重点功能）

### 总线式端口拓扑图设计方案

#### 设计目标

解决当前端口级拓扑图中每个端口都是独立节点导致的连接复杂、视觉混乱问题，实现专业、清晰的总线式端口显示效果。

#### 核心设计理念

1. **按电流方向分组**：区分端口的输入和输出方向，对应连接表中的"上下游"关系
2. **总线化显示**：熔丝和空开不区分类型，按数量（例如每10个）排列到总线上
3. **层次化布局**：设备 → 总线 → 端口的三层结构
4. **专业视觉效果**：使用不同图标区分熔丝和空开，清晰的连接线样式

#### 技术实现架构

**数据结构设计**：

```javascript
// 总线节点数据结构
const busNode = {
    id: `${deviceId}_bus_${direction}_${groupIndex}`, // 如: "device1_bus_input_1"
    type: 'bus',
    deviceId: 'device1',
    direction: 'input', // 'input' 或 'output'
    groupIndex: 1,
    portCount: 10,
    label: '输入总线1 (10端口)',
    x: calculatedX,
    y: calculatedY
};

// 端口节点数据结构
const portNode = {
    id: `${deviceId}_port_${portType}_${portNumber}`, // 如: "device1_port_F_1"
    type: 'port',
    deviceId: 'device1',
    busId: 'device1_bus_input_1',
    portType: 'F', // 'F'(熔丝) 或 'BL'(空开)
    portNumber: 1,
    label: 'F1',
    specification: '63A', // A端额定电流
    direction: 'input',
    x: calculatedX,
    y: calculatedY
};
```

**布局算法**：

1. **设备层**：设备节点居中放置
2. **总线层**：
   - 输入总线位于设备左侧
   - 输出总线位于设备右侧
   - 垂直排列多条总线
3. **端口层**：
   - 端口节点沿总线水平排列
   - 每条总线最多显示10个端口
   - 超过10个端口自动创建新总线

**连接关系**：

1. **设备到总线**：虚线连接，表示逻辑归属
2. **总线到端口**：实线连接，表示物理连接
3. **端口到端口**：普通连接线，表示实际电气连接

#### 视觉设计规范

**节点样式**：

```css
/* 设备节点 */
.device-node {
    shape: 'box';
    color: { background: '#E3F2FD', border: '#1976D2' };
    font: { size: 14, color: '#1976D2' };
}

/* 总线节点 */
.bus-node {
    shape: 'box';
    color: { background: '#F3E5F5', border: '#7B1FA2' };
    font: { size: 12, color: '#7B1FA2' };
    width: 120;
    height: 30;
}

/* 熔丝端口节点 */
.fuse-port-node {
    shape: 'circle';
    color: { background: '#FFECB3', border: '#F57C00' };
    size: 20;
    font: { size: 10 };
}

/* 空开端口节点 */
.breaker-port-node {
    shape: 'square';
    color: { background: '#E8F5E8', border: '#388E3C' };
    size: 20;
    font: { size: 10 };
}
```

**连接线样式**：

```css
/* 设备到总线连接 */
.device-to-bus {
    dashes: [5, 5];
    color: '#9E9E9E';
    width: 1;
}

/* 总线到端口连接 */
.bus-to-port {
    color: '#424242';
    width: 2;
}

/* 端口间连接 */
.port-to-port {
    color: '#D32F2F';
    width: 2;
    arrows: 'to';
}
```

#### 交互功能设计

1. **端口悬停信息**：
   - 显示端口名称（如"F1"、"BL2"）
   - 显示规格信息（"A端额定电流: 63A"）
   - 显示连接状态

2. **总线交互**：
   - 点击总线高亮所有相关端口
   - 显示总线端口统计信息

3. **设备交互**：
   - 点击设备显示所有端口信息
   - 支持折叠/展开端口显示

#### 实现优先级

**第一阶段**（核心结构）：
1. 实现总线节点和端口节点的数据结构
2. 实现基础的三层布局算法
3. 实现端口按方向和数量的自动分组

**第二阶段**（视觉优化）：
1. 完善节点和连接线的视觉样式
2. 实现熔丝和空开的图标区分
3. 优化布局算法，处理大量端口的情况

**第三阶段**（交互增强）：
1. 实现端口悬停信息显示
2. 添加总线和设备的交互功能
3. 实现端口搜索和筛选功能

#### 技术挑战与解决方案

**挑战1：大量端口的布局优化**
- 解决方案：动态计算总线数量，自适应调整节点间距

**挑战2：复杂连接的可读性**
- 解决方案：使用颜色编码和连接线分层显示

**挑战3：不同设备类型的适配**
- 解决方案：基于设备类型的端口分组规则配置

#### 预期效果

#### V2确认规则（已确认，需严格执行）
- 文案：未连接端口统一显示“空闲”，不再使用“断开态”。
- 端口名：严格采用用户提交的原始 port_name，不做重命名/翻译/裁剪。
- 布局：输入左、输出右、双向均分；仅显示有连接端口，提供“显示所有端口”开关。
- 样式：设备→端口灰线无箭头；端口↔端口高亮带箭头。
- Tooltip：包含类型、规格、方向、连接到、对端端口、电缆信息（如有）。

1. **专业性**：符合电力系统工程师的查看习惯
2. **清晰性**：层次分明，连接关系一目了然
3. **可扩展性**：支持60+端口设备的良好显示
4. **交互性**：丰富的悬停和点击交互功能

2. **设备级拓扑图**
   
   - 显示设备名称、类型
   - 不同设备类型使用不同图标/颜色
   - 支持设备层级关系显示（上级/下级设备）
   - 节点样式可配置（颜色、大小、形状）

3. **连接关系显示**
   
   - 显示设备间的供电连接关系
   - 连接线条样式区分连接类型（交流、直流、空闲）
   - 显示连接额定电流信息

4. **基础布局算法**
   
   - 自动布局（层次化布局，体现供电层级）
   - 手动拖拽调整位置
   - 布局位置持久化保存
   - 支持多种布局算法切换

#### 第二阶段：交互功能 (2-3周)

1. **节点交互**
   
   - 点击节点查看详细信息面板
   - 悬停显示基本信息工具提示
   - 双击进入设备详情页
   - 支持节点选择和多选操作

2. **图形操作**
   
   - 缩放、平移、适应窗口
   - 全屏显示模式
   - 导出为PNG/SVG图片
   - 打印功能支持

3. **筛选和搜索功能**
   
   - 按设备类型筛选
   - 按连接类型筛选
   - 设备名称快速搜索
   - 高级筛选组合条件

4. **视图切换**
   
   - 端口级视图和设备级视图切换（默认端口级视图）
   - 不同层级的拓扑图展示
   - 局部拓扑图聚焦显示
   - 端口级视图支持设备内部端口布局优化

#### 第三阶段：数据分析 (2-3周)

1. **拓扑统计**
   
   - 设备连接度统计
   - 供电层级分析
   - 连接类型分布统计
   - 设备分布统计

2. **数据导出**
   
   - 拓扑图导出为图片
   - 连接关系数据导出
   - 统计报表生成

## 技术选型分析

### 图形可视化库对比

基于调研结果，以下是主要候选库的对比：

| 库名               | 优势            | 劣势        | 适用性评分 |
| ---------------- | ------------- | --------- | ----- |
| **vis-network**  | 易用、文档完善、已集成   | 性能一般、社区维护 | ⭐⭐⭐⭐  |
| **Cytoscape.js** | 功能强大、性能好、活跃维护 | 学习曲线陡峭    | ⭐⭐⭐⭐⭐ |
| **D3.js**        | 灵活性极高、生态丰富    | 开发复杂度高    | ⭐⭐    |
| **Sigma.js**     | 性能优秀、WebGL支持  | 文档较少、功能有限 | ⭐⭐⭐   |

### 最终技术选型决策

**确定方案**: **vis-network**

**选择理由**：

1. **现有集成优势**：项目中已集成vis.js库，graph.html已实现基础拓扑图功能
2. **开发效率**：基于现有代码基础，可快速实现MVP功能，预计2-3周完成
3. **功能充分性**：vis-network完全满足当前需求（端口级拓扑图、筛选搜索、交互功能）
4. **风险控制**：避免技术栈切换带来的不确定性和额外开发成本
5. **渐进式升级**：MVP验证成功后，可根据用户反馈评估是否升级到Cytoscape.js

**技术实现要点**：

- 前端：基于现有vis.js集成，扩展节点筛选和搜索功能
- 后端：扩展现有API（/graph_data/{device_id}），支持筛选参数
- 数据模型：复用现有Device和Connection模型，添加拓扑坐标字段
- 兼容性：设计时考虑未来可能的库切换，保持API接口通用性

## 数据模型扩展方案

### 现有架构分析

经过分析，当前项目已有完善的数据模型：

- **Device模型**：包含设备基本信息（asset_id、name、station、device_type、location等）
- **Connection模型**：包含连接详细信息（source_port、target_port、cable_model、cable_specification等）
- **现有端口字段**：Connection表中已有source_port和target_port字段，无需新增Port模型

### 兼容性确认

✅ **无需新增Port模型** - 现有Connection表的source_port和target_port字段已足够支持端口级拓扑图
✅ **保持现有架构** - 基于Device和Connection两张表实现拓扑功能，与现有模块完全兼容
✅ **无需修改Excel导入** - 现有数据结构无需变更，用户资源表格保持不变

### 数据模型扩展方案

仅在现有模型基础上添加拓扑图可视化字段，通过数据库迁移脚本实现：

#### Device模型扩展

```sql
-- 添加拓扑图坐标和样式字段
ALTER TABLE devices ADD COLUMN topology_x REAL;
ALTER TABLE devices ADD COLUMN topology_y REAL;
ALTER TABLE devices ADD COLUMN topology_layer INTEGER DEFAULT 1;
ALTER TABLE devices ADD COLUMN node_style TEXT;
ALTER TABLE devices ADD COLUMN is_critical TEXT DEFAULT 'false';
ALTER TABLE devices ADD COLUMN display_priority INTEGER DEFAULT 1;
```

#### Connection模型扩展

```sql
-- 添加拓扑图连接线样式字段
ALTER TABLE connections ADD COLUMN line_color TEXT;
ALTER TABLE connections ADD COLUMN line_style TEXT DEFAULT 'solid';
ALTER TABLE connections ADD COLUMN is_primary TEXT DEFAULT 'true';
ALTER TABLE connections ADD COLUMN display_priority INTEGER DEFAULT 1;
```

### 基于连接关系的自动层级构建算法

#### 层级关系分析

现有Connection模型包含两个关键字段用于表示设备间的关系：

- `hierarchy_relation`：设备间的上下级关系（如："A上B下"、"A下B上"、"平级"）
- `upstream_downstream`：电流方向关系（如："上游"表示电流从A端设备流向B端设备，"下游"表示相反方向）

**字段含义说明**：

- `hierarchy_relation`主要用于确定设备在拓扑图中的垂直层级位置
- `upstream_downstream`主要用于确定电流流向，辅助验证和优化层级关系的合理性
- 虽然这两个字段在某种程度上存在关联性，但分别记录有助于更精确地描述设备间的复杂关系

#### 自动层级构建算法设计

**算法目标**：根据连接关系自动计算每个设备的拓扑层级（topology_layer），实现类似通信电源系统架构图的层次化布局。

**算法步骤**：

1. **构建有向图**
   
   ```python
   def build_hierarchy_graph(connections):
       """
       根据连接关系构建有向图，处理双向连接和无明确层级关系的情况
       """
       graph = defaultdict(list)  # 邻接表
       reverse_graph = defaultdict(list)  # 反向邻接表
       bidirectional_connections = []  # 双向连接列表
       peer_connections = []  # 平级连接列表
   
       for conn in connections:
           source_id = conn.source_device_id
           target_id = conn.target_device_id
   
           # 根据hierarchy_relation确定方向
           if conn.hierarchy_relation == "A上B下":
               # A设备在上层，B设备在下层
               graph[source_id].append(target_id)
               reverse_graph[target_id].append(source_id)
           elif conn.hierarchy_relation == "A下B上":
               # A设备在下层，B设备在上层
               graph[target_id].append(source_id)
               reverse_graph[source_id].append(target_id)
           elif conn.hierarchy_relation == "平级":
               # 平级关系单独处理
               peer_connections.append((source_id, target_id, conn))
           elif conn.hierarchy_relation in ["双向", "无固定层级", None, ""]:
               # 双向连接或无明确层级关系（如整流器-蓄电池）
               bidirectional_connections.append((source_id, target_id, conn))
   
       return graph, reverse_graph, bidirectional_connections, peer_connections
   ```

2. **拓扑排序计算层级**
   
   ```python
   def calculate_topology_layers(devices, connections):
       """
       使用拓扑排序算法计算设备层级，处理双向连接和平级关系
       """
       graph, reverse_graph, bidirectional_connections, peer_connections = build_hierarchy_graph(connections)
   
       # 计算入度
       in_degree = defaultdict(int)
       all_devices = set(device.id for device in devices)
   
       for device_id in all_devices:
           in_degree[device_id] = len(reverse_graph[device_id])
   
       # 找到根节点（入度为0的节点）
       queue = deque([device_id for device_id in all_devices if in_degree[device_id] == 0])
       layers = {}
       current_layer = 1
   
       while queue:
           # 处理当前层的所有节点
           layer_size = len(queue)
           for _ in range(layer_size):
               device_id = queue.popleft()
               layers[device_id] = current_layer
   
               # 更新下游节点的入度
               for neighbor in graph[device_id]:
                   in_degree[neighbor] -= 1
                   if in_degree[neighbor] == 0:
                       queue.append(neighbor)
   
           current_layer += 1
   
       # 处理双向连接设备的层级分配
       layers = handle_bidirectional_connections(layers, bidirectional_connections, devices)
   
       # 处理平级连接设备的层级分配
       layers = handle_peer_connections(layers, peer_connections)
   
       # 处理孤立节点（没有连接关系的设备）
       for device_id in all_devices:
           if device_id not in layers:
               layers[device_id] = 1  # 默认层级
   
       return layers
   ```

3. **处理双向连接和平级关系**
   
   ```python
   def handle_bidirectional_connections(layers, bidirectional_connections, devices):
       """
       处理双向连接设备的层级分配（如整流器-蓄电池）
       """
       device_types = {device.id: device.device_type for device in devices}
   
       for source_id, target_id, conn in bidirectional_connections:
           source_type = device_types.get(source_id, "")
           target_type = device_types.get(target_id, "")
   
           # 根据设备类型的典型层级关系进行智能分配
           if source_id in layers and target_id not in layers:
               # 如果一个设备已有层级，另一个设备根据类型关系分配
               if is_power_source_type(source_type) and is_storage_type(target_type):
                   # 电源设备通常在存储设备上方
                   layers[target_id] = layers[source_id] + 1
               elif is_storage_type(source_type) and is_power_source_type(target_type):
                   layers[source_id] = layers[target_id] + 1
               else:
                   # 默认放在同一层或相邻层
                   layers[target_id] = layers[source_id]
           elif target_id in layers and source_id not in layers:
               # 反向处理
               if is_power_source_type(source_type) and is_storage_type(target_type):
                   layers[source_id] = layers[target_id] - 1
               elif is_storage_type(source_type) and is_power_source_type(target_type):
                   layers[target_id] = layers[source_id] + 1
               else:
                   layers[source_id] = layers[target_id]
           elif source_id not in layers and target_id not in layers:
               # 两个设备都没有层级，根据设备类型分配
               if is_power_source_type(source_type) and is_storage_type(target_type):
                   layers[source_id] = 2  # 假设电源在第2层
                   layers[target_id] = 3  # 存储在第3层
               else:
                   layers[source_id] = 2
                   layers[target_id] = 2  # 同层
   
       return layers
   
   def handle_peer_connections(layers, peer_connections):
       """
       处理平级连接设备的层级分配
       """
       for source_id, target_id, conn in peer_connections:
           if source_id in layers and target_id not in layers:
               # 平级设备放在同一层
               layers[target_id] = layers[source_id]
           elif target_id in layers and source_id not in layers:
               layers[source_id] = layers[target_id]
           elif source_id not in layers and target_id not in layers:
               # 都没有层级，分配到默认层
               layers[source_id] = 2
               layers[target_id] = 2
   
       return layers
   
   def is_power_source_type(device_type):
       """
       判断是否为电源类设备
       基于标准设备类型列表进行判断
       """
       power_types = [
           "发电机组", "直流系统设备", "交直流配电设备", 
           "交流UPS主机", "高压配电设备", "中央空调主机",
           "太阳能光伏组件"
       ]
       return device_type in power_types
   
   def is_storage_type(device_type):
       """
       判断是否为储能类设备
       基于标准设备类型列表进行判断
       """
       storage_types = [
           "油机启动电池", "-48V直流系统2V阀控铅酸蓄电池", 
           "UPS系统阀控式铅酸蓄电池", "操作电源2V6V12V阀控式铅酸蓄电池"
       ]
       return device_type in storage_types
   ```

4. **层级优化和调整**
   
   ```python
   def optimize_layers(layers, connections):
       """
       根据upstream_downstream电流方向关系进一步优化和验证层级
       """
       # 分析电流方向关系，验证和微调层级
       for conn in connections:
           source_id = conn.source_device_id
           target_id = conn.target_device_id
   
           # 跳过双向连接和平级连接的电流方向验证
           if conn.hierarchy_relation in ["双向", "无固定层级", "平级", None, ""]:
               continue
   
           if conn.upstream_downstream == "上游":
               # 上游表示电流从source流向target，source应在上层
               if layers[source_id] >= layers[target_id]:
                   layers[target_id] = layers[source_id] + 1
           elif conn.upstream_downstream == "下游":
               # 下游表示电流从target流向source，target应在上层
               if layers[target_id] >= layers[source_id]:
                   layers[source_id] = layers[target_id] + 1
   
       return layers
   ```

#### 算法工作原理说明

**重要澄清**：算法完全基于数据表中的实际连接关系自动计算层级，不预设固定的层级结构。

**算法核心原则**：

1. **连接关系优先**：层级构建主要基于Connection表中的`hierarchy_relation`字段，而非设备类型
2. **设备类型辅助**：设备类型判断（`is_power_source_type`和`is_storage_type`函数）仅用于处理双向连接的特殊情况
3. **数据驱动准确性**：层级关系完全基于真实的设备连接数据，准确反映实际供电架构

**算法逻辑**：

1. **数据驱动**：读取Connection表中的`hierarchy_relation`（设备上下级关系）和`upstream_downstream`（电流方向）字段
2. **关系分析**：主要基于`hierarchy_relation`字段构建设备间的有向图，确定设备的层级结构
3. **层级计算**：使用拓扑排序算法，从没有上级设备的根节点开始，逐层向下计算每个设备的层级编号
4. **双向连接处理**：仅在处理`hierarchy_relation`为"双向"或"无固定层级"的连接时，才使用设备类型判断来辅助确定层级关系
5. **电流验证**：使用`upstream_downstream`字段验证和微调层级关系，确保电流流向与层级结构一致
6. **动态生成**：最终的层级数量和结构完全由实际连接关系决定，可能是3层、4层、5层或更多

**典型应用场景举例**（仅为说明，非固定模式）：

- **某个具体项目可能的层级结构**：
  - 第1层：市电输入、UPS、发电机等电源设备
  - 第2层：配电柜、总配电箱
  - 第3层：分配电箱、开关电源
  - 第4层：通信设备、负载设备
- **另一个项目可能完全不同**：
  - 第1层：高压进线
  - 第2层：变压器
  - 第3层：低压配电
  - 第4层：UPS系统
  - 第5层：直流配电
  - 第6层：通信设备

**算法优势**：

1. **完全自动化**：无需手动设置层级，系统根据实际连接关系自动计算
2. **数据驱动准确性**：层级关系完全基于真实的设备连接数据，准确反映实际供电架构
3. **灵活适应性**：支持任意复杂度的供电拓扑结构，层级数量由实际情况决定
4. **动态更新**：当连接关系变更时，重新运行算法即可自动更新层级结构

#### API接口设计

```python
@app.post("/api/topology/calculate-layers")
async def calculate_topology_layers_api(db: Session = Depends(get_db)):
    """
    重新计算所有设备的拓扑层级
    """
    devices = db.query(Device).all()
    connections = db.query(Connection).all()

    # 计算层级
    layers = calculate_topology_layers(devices, connections)
    layers = optimize_layers(layers, connections)

    # 更新数据库
    for device in devices:
        device.topology_layer = layers.get(device.id, 1)

    db.commit()

    return {
        "message": "拓扑层级计算完成",
        "layers": layers,
        "total_layers": max(layers.values()) if layers else 1
    }
```

#### 对应的SQLAlchemy模型更新

```python
class Device(Base):
    # ... 现有字段保持不变 ...

    # 新增拓扑图字段
    topology_x = Column(Float, nullable=True)  # X坐标
    topology_y = Column(Float, nullable=True)  # Y坐标
    topology_layer = Column(Integer, default=1)  # 拓扑层级
    node_style = Column(String, nullable=True)  # 节点样式JSON

class Connection(Base):
    # ... 现有字段保持不变 ...

    # 新增拓扑图字段
    line_color = Column(String, nullable=True)  # 连接线颜色
    line_style = Column(String, default="solid")  # 连接线样式
    is_primary = Column(String, default="true")  # 是否主要连接
```

#### 数据迁移策略

1. **添加新字段**：使用数据库迁移脚本为现有表添加拓扑相关字段
2. **初始化数据**：为现有设备和连接初始化默认的拓扑配置
3. **建立索引**：为拓扑查询相关字段建立适当的索引

## 开发计划

### 时间安排

**总计：6-8周**

#### 第一阶段：基础拓扑显示 (2-3周)

- **Week 1**: 
  - 基于现有vis-network集成扩展功能
  - 数据模型扩展（在现有Device和Connection模型上添加拓扑字段）
  - 数据库迁移脚本开发和测试
- **Week 2**: 
  - 扩展现有API（/graph_data/{device_id}）支持筛选参数
  - 基于现有graph.html扩展端口级拓扑显示
  - 基础样式配置（三相交流黄绿红，直流蓝负红正）
- **Week 3**: 
  - 端口级拓扑图显示实现（基于source_port和target_port字段）
  - vis-network布局算法优化（hierarchical、physics）
  - 节点样式和设备类型图标配置

#### 第二阶段：交互功能 (2-3周)

- **Week 4**: 
  - 节点拖拽和位置调整功能
  - 连接线汇聚显示（多条连接合并为一条）
  - 全屏显示模式和视图切换
- **Week 5**: 
  - 基于现有source_port和target_port字段的连接级拓扑显示
  - 点击汇聚线展开详细连接功能
  - 设备和连接详情弹窗显示
- **Week 6**: 
  - 筛选和搜索功能（按局站、设备类型、连接类型）
  - 布局位置持久化保存
  - 性能优化和用户体验改进

#### 第三阶段：数据分析 (2周)

- **Week 7**: 
  - 拓扑统计功能实现（设备连接度、层级分析、类型分布）
  - 数据导出功能开发（JSON格式）
- **Week 8**: 
  - 统计报表生成和展示
  - 功能整合测试、文档完善和部署准备

### 技术实现要点

#### 前端可视化实现

**技术选型：vis-network**

选择理由：

- ✅ **轻量级**：单文件引入，无需复杂构建
- ✅ **功能完整**：支持节点、边、布局、交互
- ✅ **性能优秀**：适合中等规模网络（100-1000节点）
- ✅ **文档完善**：官方文档详细，社区活跃
- ✅ **兼容性好**：与Bootstrap和现有技术栈完美兼容

**拓扑图核心功能**

节点显示：

- **设备信息**：显示设备名称、型号、位置等基本信息
- **状态指示**：通过颜色区分设备类型和状态
- **交互提示**：悬停显示详细信息，点击查看设备详情
- **备注信息**：在节点提示框中显示重要备注（如"维修旁路"）

连接显示：

- **连接类型**：不同颜色和样式表示交流、直流连接
- **方向指示**：箭头显示供电方向
- **连接信息**：悬停显示连接详情（电缆型号、规格等）
- **备注信息**：在连接详情中显示重要备注信息

层次化布局算法：
基于自动计算的topology_layer实现层次化布局：

```javascript
// 层次化布局配置
const hierarchicalOptions = {
    layout: {
        hierarchical: {
            enabled: true,
            levelSeparation: 150,  // 层级间距
            nodeSpacing: 100,      // 同层节点间距
            treeSpacing: 200,      // 树状结构间距
            blockShifting: true,   // 允许块移动优化
            edgeMinimization: true, // 最小化边交叉
            parentCentralization: true, // 父节点居中
            direction: 'UD',       // 上下布局（Up-Down）
            sortMethod: 'directed' // 有向图排序
        }
    }
};

// 节点数据处理 - 根据topology_layer设置层级
function processNodesForHierarchy(devices) {
    return devices.map(device => ({
        id: device.id,
        label: device.name,
        level: device.topology_layer, // 关键：设置节点层级
        color: getDeviceColor(device.device_type),
        shape: 'box',
        font: { size: 12 },
        title: createNodeTooltip(device) // 包含备注信息的提示框
    }));
}

// 创建节点提示框（包含备注信息）
function createNodeTooltip(device) {
    let tooltip = `<div class="tooltip-content">`;
    tooltip += `<h6>${device.name}</h6>`;
    tooltip += `<p><strong>型号：</strong>${device.model || 'N/A'}</p>`;
    tooltip += `<p><strong>位置：</strong>${device.location || 'N/A'}</p>`;
    tooltip += `<p><strong>功率：</strong>${device.power_rating || 'N/A'}</p>`;

    // 显示备注信息（如果存在）
    if (device.remark && device.remark.trim()) {
        tooltip += `<div class="tooltip-remark">`;
        tooltip += `<strong>备注：</strong>${device.remark}`;
        tooltip += `</div>`;
    }

    tooltip += `</div>`;
    return tooltip;
}
```

自动布局与手动调整：

- **自动层次布局**：基于topology_layer自动排列设备
- **力导向优化**：在层次基础上优化节点间距和连接路径
- **手动微调**：支持拖拽调整节点位置，保存用户自定义坐标

#### 后端API设计

基于现有API扩展，保持与现有架构的兼容性：

```python
# 扩展现有拓扑图数据API
@app.get("/graph_data/{device_id}")
async def get_graph_data(
    device_id: int,
    level: str = "port",  # "device" 或 "port"
    station: str = None,
    device_type: str = None,
    connection_type: str = None,
    show_critical_only: bool = False
):
    """获取拓扑图数据（扩展现有API支持筛选）"""

# 新增拓扑图布局API
@app.post("/api/topology/layout")
async def save_topology_layout(layout_data: dict):
    """保存拓扑图布局配置"""

@app.get("/api/topology/layout/{device_id}")
async def get_topology_layout(device_id: int):
    """获取指定设备的拓扑图布局配置"""

# 拓扑图筛选选项API
@app.get("/api/topology/filter-options")
async def get_filter_options():
    """获取筛选选项（设备类型、连接类型等）"""
    return {
        "device_types": STANDARD_DEVICE_TYPES,
        "connection_types": ["交流", "直流"],
        "stations": await get_unique_stations()
    }

# 拓扑统计API
@app.get("/api/topology/statistics/{device_id}")
async def get_topology_statistics(device_id: int):
    """获取指定设备拓扑网络统计信息"""
```

#### 前端集成要点

基于现有graph.html扩展，使用vis-network实现拓扑图功能：

```javascript
// 扩展现有拓扑图功能
class EnhancedTopologyViewer {
  constructor(containerId, options = {}) {
    this.container = document.getElementById(containerId);
    this.network = null;
    this.nodes = new vis.DataSet();
    this.edges = new vis.DataSet();
    this.options = {
      level: 'port', // 'device' 或 'port'
      layout: {
        hierarchical: {
          enabled: true,
          direction: 'UD',
          sortMethod: 'directed'
        }
      },
      physics: {
        enabled: true,
        hierarchicalRepulsion: {
          centralGravity: 0.0,
          springLength: 100,
          springConstant: 0.01,
          nodeDistance: 120,
          damping: 0.09
        }
      },
      interaction: {
        dragNodes: true,
        zoomView: true,
        selectConnectedEdges: false
      },
      ...options
    };

    this.initNetwork();
    this.bindEvents();
    this.addControlPanel();
  }

  // 初始化vis-network实例
  initNetwork() {
    // vis-network节点样式配置
    const nodeOptions = {
      shape: 'box',
      font: {
        size: 12,
        face: '微软雅黑',
        color: '#262626'
      },
      borderWidth: 2,
      borderWidthSelected: 3,
      chosen: true,
      shadow: {
        enabled: true,
        color: 'rgba(0,0,0,0.2)',
        size: 5,
        x: 2,
        y: 2
      }
    };

    // vis-network边样式配置
    const edgeOptions = {
      arrows: {
        to: {
          enabled: true,
          scaleFactor: 1.2
        }
      },
      smooth: {
        enabled: true,
        type: 'dynamic',
        roundness: 0.5
      },
      font: {
        size: 10,
        face: '微软雅黑',
        strokeWidth: 2,
        strokeColor: '#ffffff'
      }
    };

    // 合并配置选项
    this.options.nodes = { ...nodeOptions, ...this.options.nodes };
    this.options.edges = { ...edgeOptions, ...this.options.edges };

    // 创建vis-network实例
     const data = {
       nodes: this.nodes,
       edges: this.edges
     };

     this.network = new vis.Network(this.container, data, this.options);
   }

   // 添加控制面板（筛选和搜索功能）
   addControlPanel() {
     const controlPanel = document.createElement('div');
     controlPanel.className = 'topology-control-panel';
     controlPanel.innerHTML = `
       <div class="row mb-3">
         <div class="col-md-3">
           <label class="form-label">显示级别</label>
           <select class="form-select" id="levelSelect">
             <option value="port">端口级</option>
             <option value="device">设备级</option>
           </select>
         </div>
         <div class="col-md-3">
           <label class="form-label">设备类型</label>
           <select class="form-select" id="deviceTypeFilter">
             <option value="">全部</option>
             <option value="发电机组">发电机组</option>
             <option value="直流系统设备">直流系统设备</option>
             <option value="交直流配电设备">交直流配电设备</option>
             <option value="交流UPS主机">交流UPS主机</option>
             <option value="高压配电设备">高压配电设备</option>
             <option value="中央空调主机">中央空调主机</option>
             <option value="机房专用精密空调">机房专用精密空调</option>
             <option value="普通空调">普通空调</option>
             <option value="太阳能光伏组件">太阳能光伏组件</option>
             <option value="油机启动电池">油机启动电池</option>
             <option value="-48V直流系统2V阀控铅酸蓄电池">-48V直流系统2V阀控铅酸蓄电池</option>
             <option value="UPS系统阀控式铅酸蓄电池">UPS系统阀控式铅酸蓄电池</option>
             <option value="操作电源2V6V12V阀控式铅酸蓄电池">操作电源2V6V12V阀控式铅酸蓄电池</option>
           </select>
         </div>
         <div class="col-md-3">
           <label class="form-label">连接类型</label>
           <select class="form-select" id="connectionTypeFilter">
             <option value="">全部</option>
             <option value="交流">交流</option>
             <option value="直流">直流</option>
           </select>
         </div>
         <div class="col-md-3">
           <label class="form-label">设备搜索</label>
           <input type="text" class="form-control" id="deviceSearch" placeholder="输入设备名称...">
         </div>
       </div>
       <div class="row mb-3">
         <div class="col-md-6">
           <div class="form-check">
             <input class="form-check-input" type="checkbox" id="showCriticalOnly">
             <label class="form-check-label" for="showCriticalOnly">仅显示关键设备</label>
           </div>
         </div>
         <div class="col-md-6 text-end">
           <button class="btn btn-primary" id="applyFilters">应用筛选</button>
           <button class="btn btn-secondary" id="resetFilters">重置</button>
           <button class="btn btn-info" id="fullscreenBtn">全屏</button>
         </div>
       </div>
     `;

     this.container.parentNode.insertBefore(controlPanel, this.container);
     this.bindFilterEvents();
   }

   // 绑定筛选事件
   bindFilterEvents() {
     document.getElementById('applyFilters').addEventListener('click', () => {
       this.applyFilters();
     });

     document.getElementById('resetFilters').addEventListener('click', () => {
       this.resetFilters();
     });

     document.getElementById('fullscreenBtn').addEventListener('click', () => {
       this.toggleFullscreen();
     });

     document.getElementById('deviceSearch').addEventListener('input', (e) => {
       this.searchDevices(e.target.value);
     });
   }

   // 应用筛选条件
   async applyFilters() {
     const filters = {
       level: document.getElementById('levelSelect').value,
       device_type: document.getElementById('deviceTypeFilter').value,
       connection_type: document.getElementById('connectionTypeFilter').value,
       show_critical_only: document.getElementById('showCriticalOnly').checked
     };

     await this.loadTopologyData(this.currentDeviceId, filters);
   }

   // 加载拓扑图数据
   async loadTopologyData(deviceId, filters = {}) {
     try {
       const params = new URLSearchParams({
         level: filters.level || 'port',
         ...(filters.device_type && { device_type: filters.device_type }),
         ...(filters.connection_type && { connection_type: filters.connection_type }),
         ...(filters.show_critical_only && { show_critical_only: 'true' })
       });

       const response = await fetch(`/graph_data/${deviceId}?${params}`);
       const data = await response.json();

       this.updateNetworkData(data);
     } catch (error) {
       console.error('加载拓扑图数据失败:', error);
     }
   }

   // 更新网络数据
   updateNetworkData(data) {
     // 处理节点数据
     const nodes = data.nodes.map(node => ({
       id: node.id,
       label: node.label,
       color: this.getNodeColor(node.device_type),
       shape: this.getNodeShape(node.device_type),
       size: node.is_critical === 'true' ? 30 : 20,
       font: {
         size: node.is_critical === 'true' ? 14 : 12,
         color: '#262626'
       },
       borderWidth: node.is_critical === 'true' ? 3 : 2,
       ...node
     }));

     // 处理边数据
     const edges = data.edges.map(edge => ({
       id: edge.id,
       from: edge.from,
       to: edge.to,
       label: edge.label,
       color: this.getEdgeColor(edge.cable_type),
       width: this.getEdgeWidth(edge.cable_type),
       dashes: edge.cable_type ? false : [5, 5], // 空闲端口显示虚线
       ...edge
     }));

     // 更新数据集
     this.nodes.clear();
     this.edges.clear();
     this.nodes.add(nodes);
     this.edges.add(edges);
   }

   // 获取节点颜色
   getNodeColor(deviceType) {
     const colorMap = {
       'UPS': '#1890ff',
       '高压柜': '#722ed1',
       '低压柜': '#52c41a',
       '变压器': '#fa8c16',
       '直流控制屏': '#faad14',
       'ATS柜': '#13c2c2',
       '直流配电柜': '#eb2f96'
     };
     return colorMap[deviceType] || '#d9d9d9';
   }

   // 获取边颜色
   getEdgeColor(cableType) {
     if (cableType && cableType.includes('交流')) {
       return '#FFD700'; // 黄色 - 交流
     } else if (cableType && cableType.includes('直流')) {
       return '#FF0000'; // 红色 - 直流
     }
     return '#CCCCCC'; // 灰色 - 空闲或未知
   }

   // 获取边宽度
   getEdgeWidth(cableType) {
     if (cableType && (cableType.includes('交流') || cableType.includes('直流'))) {
       return 3; // 电力连接使用较粗的线条
     }
     return 2;
   }
}
// 使用示例
const topologyViewer = new EnhancedTopologyViewer('topology-container', {
  level: 'port',
  layout: {
    hierarchical: {
      enabled: true,
      direction: 'UD'
    }
  }
});

// 加载指定设备的拓扑图
topologyViewer.loadTopologyData(deviceId);
```

#### 具体实施步骤

**第1步：扩展现有API**

```python
# 在main.py中扩展现有的graph_data API
@app.get("/graph_data/{device_id}")
async def get_graph_data(
    device_id: int,
    level: str = "port",
    station: str = None,
    device_type: str = None,
    connection_type: str = None,
    show_critical_only: bool = False,
    db: Session = Depends(get_db)
):
    """获取拓扑图数据（支持筛选参数）"""
    # 基于现有BFS算法扩展筛选逻辑
    visited = set()
    queue = deque([device_id])
    nodes = []
    edges = []

    while queue:
        current_device_id = queue.popleft()
        if current_device_id in visited:
            continue
        visited.add(current_device_id)

        # 获取设备信息（应用设备类型筛选）
        device = db.query(Device).filter(Device.id == current_device_id).first()
        if not device:
            continue

        # 应用筛选条件
        if device_type and device.device_type != device_type:
            continue
        if station and device.station != station:
            continue
        if show_critical_only and device.is_critical != 'true':
            continue

        # 构建节点数据
        node_data = {
            "id": device.id,
            "label": device.name,
            "device_type": device.device_type,
            "station": device.station,
            "power_rating": device.power_rating,
            "remark": device.remark,
            "title": f"设备: {device.name}\n类型: {device.device_type}\n局站: {device.station}" + (f"\n备注: {device.remark}" if device.remark else "")
        }
        nodes.append(node_data)

        # 获取连接信息（应用连接类型筛选和级别筛选）
        if level == "port":
            # 端口级显示：显示具体端口连接
            connections = db.query(Connection).filter(
                or_(Connection.source_device_id == current_device_id,
                    Connection.target_device_id == current_device_id)
            ).all()

            for conn in connections:
                if connection_type and conn.cable_model != connection_type:
                    continue

                # 构建边数据（端口级）
                edge_data = {
                    "id": f"conn_{conn.id}",
                    "from": conn.source_device_id,
                    "to": conn.target_device_id,
                    "label": f"{conn.source_port} → {conn.target_port}",
                    "source_port": conn.source_port,
                    "target_port": conn.target_port,
                    "connection_type": conn.connection_type,
                    "cable_model": conn.cable_model,
                    "cable_specification": conn.cable_specification,
                    "rated_current": conn.rated_current,
                    "remark": conn.remark,
                    "title": f"连接: {conn.source_port} → {conn.target_port}\n电缆: {conn.cable_model}" + (f"\n备注: {conn.remark}" if conn.remark else "")
                }
                edges.append(edge_data)
        else:
            # 设备级显示：汇聚显示设备间连接
            # 实现设备级汇聚逻辑
            pass

    return {"nodes": nodes, "edges": edges}
```

**第2步：扩展graph.html页面**

```html
<!-- 在现有graph.html基础上添加筛选控件 -->
<div class="container-fluid mt-3">
    <div class="row">
        <div class="col-12">
            <!-- 筛选控制面板 -->
            <div class="card mb-3">
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-2">
                            <label class="form-label">显示级别</label>
                            <select class="form-select" id="levelSelect">
                                <option value="port">端口级</option>
                                <option value="device">设备级</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">设备类型</label>
                            <select class="form-select" id="deviceTypeFilter">
                                <option value="">全部</option>
                                <!-- 动态加载设备类型选项 -->
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">连接类型</label>
                            <select class="form-select" id="connectionTypeFilter">
                                <option value="">全部</option>
                                <!-- 动态加载连接类型选项 -->
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">设备搜索</label>
                            <input type="text" class="form-control" id="deviceSearch" placeholder="输入设备名称...">
                        </div>
                        <div class="col-md-3">
                            <div class="d-flex align-items-end h-100">
                                <button class="btn btn-primary me-2" id="applyFilters">应用筛选</button>
                                <button class="btn btn-secondary me-2" id="resetFilters">重置</button>
                                <button class="btn btn-info" id="fullscreenBtn">全屏</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 现有的拓扑图容器 -->
            <div id="mynetworkid" style="height: 600px; border: 1px solid #ddd;"></div>
        </div>
    </div>
</div> 
        name: this.options.layout,
        animate: true,
        animationDuration: 1000
      }).run();

      // 恢复保存的节点位置
      this.restoreNodePositions();

    } catch (error) {
      console.error('Failed to load topology data:', error);
      this.showError('加载拓扑数据失败');
    }
  }

  // 处理汇聚连接（多条连接合并显示）
  processAggregatedConnections(data) {
    const connectionMap = new Map();
    const nodes = data.nodes || [];
    const edges = data.edges || [];

    // 按源设备和目标设备分组连接
    edges.forEach(edge => {
      const key = `${edge.from}-${edge.to}`;
      if (!connectionMap.has(key)) {
        connectionMap.set(key, []);
      }
      connectionMap.get(key).push(edge);
    });

    const processedEdges = [];

    connectionMap.forEach((connections, key) => {
      if (connections.length === 1) {
        // 单条连接直接添加
        processedEdges.push(connections[0]);
      } else {
        // 多条连接创建汇聚边
        const firstConn = connections[0];
        processedEdges.push({
          id: `aggregated_${key}`,
          from: firstConn.from,
          to: firstConn.to,
          aggregated: true,
          connections: connections,
          count: connections.length,
          color: '#1890ff',
          width: 6,
          label: `${connections.length}条连接`
        });
      }
    });

    return {
      nodes: nodes,
      edges: processedEdges
    };
  }

  // 切换视图级别
  switchLevel(level) {
    this.options.level = level;
    this.loadTopologyData(level);
  }

  // 显示节点详情
  showNodeDetails(nodeData) {
    const modal = new bootstrap.Modal(document.getElementById('deviceModal'));
    document.getElementById('deviceModalBody').innerHTML = `
      <div class="device-details">
        <h5 class="mb-3">${nodeData.name}</h5>
        <div class="row">
          <div class="col-6">
            <p><strong>资产编号:</strong> ${nodeData.asset_id || 'N/A'}</p>
            <p><strong>设备类型:</strong> ${nodeData.device_type || 'N/A'}</p>
            <p><strong>局站:</strong> ${nodeData.station || 'N/A'}</p>
          </div>
          <div class="col-6">
            <p><strong>位置:</strong> ${nodeData.location || 'N/A'}</p>

            <p><strong>额定功率:</strong> ${nodeData.power_rating || 'N/A'}</p>
          </div>
        </div>
      </div>
    `;
    modal.show();
  }

  // 显示连接详情
  showConnectionDetails(edgeData) {
    const modal = new bootstrap.Modal(document.getElementById('connectionModal'));
    document.getElementById('connectionModalBody').innerHTML = `
      <div class="connection-details">
        <h5 class="mb-3">连接详情</h5>
        <div class="row">
          <div class="col-6">
            <p><strong>A端端口:</strong> ${edgeData.source_port || 'N/A'}</p>
            <p><strong>B端端口:</strong> ${edgeData.target_port || 'N/A'}</p>
            <p><strong>连接类型:</strong> ${edgeData.connection_type || 'N/A'}</p>
          </div>
          <div class="col-6">
            <p><strong>电缆型号:</strong> ${edgeData.cable_model || 'N/A'}</p>
            <p><strong>电缆规格:</strong> ${edgeData.cable_specification || 'N/A'}</p>
            <p><strong>额定电流:</strong> ${edgeData.rated_current || 'N/A'}A</p>
          </div>
        </div>
        ${edgeData.remark ? `
        <div class="row mt-3">
          <div class="col-12">
            <div class="alert alert-info">
              <strong><i class="fas fa-info-circle"></i> 备注:</strong> ${edgeData.remark}
            </div>
          </div>
        </div>` : ''}
        </div>
      </div>
    `;
    modal.show();
  }

  // 展开汇聚连接
  expandAggregatedConnections(edgeId) {
    const currentEdges = this.network.body.data.edges.get();
    const edge = currentEdges.find(e => e.id === edgeId);

    if (edge && edge.connections && edge.connections.length > 1) {
      // 移除汇聚边
      this.network.body.data.edges.remove(edgeId);

      // 添加详细连接
      const newEdges = edge.connections.map((conn, index) => ({
        id: `${edge.id}_${index}`,
        from: edge.from,
        to: edge.to,
        ...conn,
        expanded: true,
        smooth: {
          enabled: true,
          type: 'curvedCW',
          roundness: (index - (edge.connections.length - 1) / 2) * 0.3
        }
      }));

      this.network.body.data.edges.add(newEdges);
    }
  }

  // 保存节点位置
  async saveNodePosition(nodeId, position) {
    try {
      await fetch(`/api/devices/${nodeId}/position`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          topology_x: position.x,
          topology_y: position.y
        })
      });
    } catch (error) {
      console.error('Failed to save node position:', error);
    }
  }

  // 恢复节点位置
  async restoreNodePositions() {
    const nodes = this.network.body.data.nodes.get();
    const updatedNodes = nodes.map(node => {
      if (node.topology_x !== undefined && node.topology_y !== undefined) {
        return {
          ...node,
          x: node.topology_x,
          y: node.topology_y,
          fixed: { x: false, y: false }
        };
      }
      return node;
    });

    this.network.body.data.nodes.update(updatedNodes);
  }

  // 添加全屏按钮
  addFullscreenButton() {
    const button = document.createElement('button');
    button.innerHTML = '<i class="fas fa-expand"></i>';
    button.className = 'btn btn-sm btn-outline-secondary position-absolute';
    button.style.cssText = 'top: 10px; right: 10px; z-index: 1000;';
    button.title = '全屏显示';
    button.onclick = () => this.toggleFullscreen();
    this.container.appendChild(button);
  }

  // 切换全屏
  toggleFullscreen() {
    if (!document.fullscreenElement) {
      this.container.requestFullscreen();
      this.container.classList.add('fullscreen-mode');
    } else {
      document.exitFullscreen();
      this.container.classList.remove('fullscreen-mode');
    }
  }

  // 显示节点提示框
  showNodeTooltip(nodeData, position) {
    const tooltip = document.createElement('div');
    tooltip.className = 'topology-tooltip';
    tooltip.innerHTML = `
      <div class="tooltip-header">${nodeData.name}</div>
      <div class="tooltip-body">
        <div>类型: ${nodeData.device_type}</div>
        <div>局站: ${nodeData.station || 'N/A'}</div>
        <div>功率: ${nodeData.power_rating || 'N/A'}</div>
        ${nodeData.remark ? `<div class="tooltip-remark">备注: ${nodeData.remark}</div>` : ''}
      </div>
    `;
    tooltip.style.cssText = `
      position: absolute;
      left: ${position.x + 10}px;
      top: ${position.y - 10}px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 1000;
      pointer-events: none;
    `;
    document.body.appendChild(tooltip);
    this.currentTooltip = tooltip;
  }

  // 隐藏提示框
  hideTooltip() {
    if (this.currentTooltip) {
      document.body.removeChild(this.currentTooltip);
      this.currentTooltip = null;
    }
  }



  // 导出拓扑数据
  async exportTopologyData(format = 'json') {
    try {
      const response = await fetch(`/api/topology/export?format=${format}`);
      const data = await response.json();

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `topology_data_${new Date().toISOString().slice(0,10)}.${format}`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Export failed:', error);
    }
  }

  // 错误显示
  showError(message) {
    const alert = document.createElement('div');
    alert.className = 'alert alert-danger alert-dismissible fade show position-fixed';
    alert.style.cssText = 'top: 20px; right: 20px; z-index: 2000;';
    alert.innerHTML = `
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    document.body.appendChild(alert);

    setTimeout(() => {
      if (alert.parentNode) {
        alert.parentNode.removeChild(alert);
      }
    }, 5000);
  }
}

// 使用示例
const topologyViewer = new EnhancedTopologyViewer('topology-container', {
  level: 'device',
  layout: 'hierarchicalRepulsion'
});

// 加载设备级拓扑
topologyViewer.loadTopologyData('device', { station: '某局站' });

// CSS样式
const style = document.createElement('style');
style.textContent = `
.topology-container {
  width: 100%;
  height: 600px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  position: relative;
}

.topology-container.fullscreen-mode {
  width: 100vw !important;
  height: 100vh !important;
  border: none;
  border-radius: 0;
}

.topology-tooltip {
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.topology-tooltip .tooltip-remark {
  color: #ff6b35;
  font-weight: 500;
  margin-top: 4px;
  padding-top: 4px;
  border-top: 1px solid rgba(255,255,255,0.3);
}

.device-details .badge {
  font-size: 0.75em;
}

.connection-details p {
  margin-bottom: 0.5rem;
}

.connection-details .alert-info {
  background-color: #e3f2fd;
  border-color: #2196f3;
  color: #1976d2;
  font-size: 0.9em;
}
`;
document.head.appendChild(style);
```

## 风险评估与应对

### 主要风险

1. **性能风险**
   
   - 风险：大量节点时渲染性能下降
   - 应对：实现分页加载、节点聚合

2. **数据一致性风险**
   
   - 风险：拓扑数据与实际数据不同步
   - 应对：建立数据同步机制

3. **用户体验风险**
   
   - 风险：复杂操作影响易用性
   - 应对：渐进式功能展示、用户引导

4. **技术债务风险**
   
   - 风险：快速开发导致代码质量问题
   - 应对：代码审查、重构计划

### 成功标准

1. **功能标准**
   
   - 能够显示完整的设备拓扑关系
   - 支持基本的交互操作
   - 响应时间 < 2秒（100个节点内）

2. **质量标准**
   
   - 代码覆盖率 > 80%
   - 无严重bug
   - 用户操作流畅

3. **可维护性标准**
   
   - 代码结构清晰
   - 文档完整
   - 易于扩展

## 后续扩展规划

### 短期扩展 (3个月内)

1. 多层拓扑支持
2. 实时数据更新
3. 更多布局算法

### 中期扩展 (6个月内)

1. 3D拓扑显示
2. 时间轴功能
3. 高级分析算法

### 长期扩展 (1年内)

1. 地理位置集成
2. 预测性分析
3. 智能推荐

## 总结

本拓扑图功能开发计划严格基于现有架构，确保与项目现状完全融合，不影响现有功能。

### 核心特点

1. **完全兼容现有架构**
   
   - 基于现有Device和Connection两张表实现
   - 无需新增Port模型，利用现有source_port和target_port字段
   - 保持现有Excel导入流程不变，仅需用户在cable_type字段填入"交流"或"直流"
   - 与设备管理、连接关系管理、端口统计分析、设备生命周期管理模块完全兼容

2. **专注资源级管理**
   
   - 纯粹的设备拓扑可视化，不涉及网络管理功能
   - 去除故障影响分析、供电路径追踪等网管功能
   - 聚焦于设备连接关系的直观展示

3. **实用的可视化功能**
   
   - 交流电缆黄色表示，直流电缆红色表示，空闲端口灰色虚线
   - 基于A端额定电流自动调节连接线粗细（2-8px）
   - 支持全屏显示和拖拽调节设备位置
   - 多条连接线汇聚显示，点击展开查看详情
   - 设备级和端口级两种视图模式

4. **渐进式实施**
   
   - 6-8周分3阶段开发：基础显示→交互功能→数据分析
   - 仅通过数据库迁移添加可视化字段，不破坏现有数据
   - 风险可控，可随时回退

### 技术保障

- **前端**：基于现有Bootstrap + vis-network，轻量级无依赖冲突
- **后端**：扩展现有FastAPI接口，复用现有数据访问层
- **数据库**：仅添加可视化字段，保持现有表结构和关系
- **部署**：无需额外部署组件，集成到现有系统

### 预期效果

✅ **零影响集成** - 不影响现有任何功能和数据
✅ **直观可视化** - 设备连接关系一目了然
✅ **操作便捷** - 拖拽调节、全屏查看、详情展示
✅ **数据一致** - 与现有管理模块数据完全同步
✅ **易于维护** - 基于现有技术栈，团队无学习成本

通过本方案的实施，将为动力资源系统增加强大的可视化能力，提升用户体验，同时确保系统的稳定性和可维护性。

## 双向连接问题的完整解决方案

针对用户提出的"整流器与蓄电池"这类双向连接问题，我们的解决方案包括：

### 1. 数据模型层面

- `hierarchy_relation`字段支持"双向"、"无固定层级"等值
- 保持现有的`upstream_downstream`字段用于电流方向记录
- 不需要修改现有数据表结构，仅扩展字段值的含义

### 2. 算法层面

- `build_hierarchy_graph`函数识别并分离双向连接和平级连接
- `handle_bidirectional_connections`函数根据设备类型智能分配层级
- 电源类设备（整流器、开关电源、UPS）通常放在储能设备（蓄电池、电池组）上方
- `optimize_layers`函数跳过双向连接的电流方向验证，避免层级冲突

### 3. 可视化层面

- 所有连接关系都会在拓扑图中显示，确保完整性
- 双向连接可使用特殊样式（如虚线、不同颜色）进行区分
- 连接线显示物理连接关系，但不强制影响设备的垂直层级布局
- 支持在连接线上显示当前电流方向的动态指示

### 4. 实际应用场景

- **整流器-蓄电池连接**：整流器在上层，蓄电池在下层，连接线显示物理连接
- **正常供电时**：`upstream_downstream`记录为"上游"（整流器→蓄电池）
- **停电放电时**：`upstream_downstream`可更新为"下游"（蓄电池→整流器），但设备层级保持不变
- **拓扑图显示**：设备位置稳定，连接线可动态显示电流方向箭头

### 5. 技术优势

- **稳定的视觉布局**：设备层级基于设备类型和典型供电关系确定，不会因工况变化而频繁调整
- **完整的连接信息**：所有物理连接都能正确显示，不遗漏任何连接关系
- **灵活的状态表示**：通过`upstream_downstream`字段和可视化样式动态反映当前电流状态
- **向后兼容**：现有数据和功能完全不受影响，仅增强可视化能力

这样既保证了拓扑图的视觉合理性和稳定性，又准确反映了实际的电气连接关系和动态工况变化。

## 设备类型和连接类型一致性问题分析与解决方案

### 问题识别

根据用户反馈，在`get_filter_options` API和整个设计文档中存在以下一致性问题：

#### 1. 设备类型命名不一致问题

**API中定义的设备类型**：

```python
"device_types": ["高压柜", "低压柜", "变压器", "UPS", "直流控制屏", "ATS柜", "直流配电柜"]
```

**算法中使用的设备类型**（在`is_power_source_type`和`is_storage_type`函数中）：

```python
# 电源类设备
power_source_types = ["整流器", "UPS", "变压器", "发电机"]
# 储能类设备  
storage_types = ["蓄电池", "电容器"]
```

**Excel数据源中的设备类型**（）：

- 实际业务中的设备类型可能包含更多种类
- 用户填表时应从标准设备类型列表中选择

#### 2. 连接类型定义混乱问题

**API中定义的连接类型**：

```python
"connection_types": ["电力电缆", "控制电缆", "光纤"]
```

**数据模型中的连接类型字段**：

- `connection_type`：存储"交流"、"直流"
- `cable_type`：存储"交流"、"直流"（用于电流类型区分）

**Excel连接表中的连接类型**：

- 定义为"交流/直流"
- 与API中的"交流"、"直流"匹配 ✅

### 解决方案

#### 1. 统一设备类型定义

**建议采用标准设备类型列表**：

```python
# 标准设备类型（与Excel设备表对应）
STANDARD_DEVICE_TYPES = [
    "发电机组", "直流系统设备", "交直流配电设备", "交流UPS主机", 
    "高压配电设备", "中央空调主机", "机房专用精密空调", "普通空调", 
    "太阳能光伏组件", "油机启动电池", "-48V直流系统2V阀控铅酸蓄电池", 
    "UPS系统阀控式铅酸蓄电池", "操作电源2V6V12V阀控式铅酸蓄电池"
]
```

**用户填表规则**：

- 用户在Excel设备表的"设备类型"字段中必须从标准列表中选择
- 系统提供设备类型下拉选项，确保数据一致性
- 支持设备类型的扩展和维护

#### 2. 明确连接类型字段用途

**重新定义连接相关字段**：

1. **connection_type字段**（连接方式）：
   
   - 取值："交流"、"直流"
- 对应Excel连接表"连接类型（交流/直流）"
  
  - 用于描述物理连接方式
2. **cable_type字段**（电流类型）：
   
   - 取值："交流"、"直流"（直接取excel连接表”连接类型（交流/直流）”列单元格里的值，”交流“or”直流“）
   - 用于区分电流类型，影响可视化样式
   - 保持现有定义不变

3. **cable_model字段**（电缆型号）：
   
   - 存储具体的电缆型号信息
   - 对应Excel连接表"电缆型号"

**修正API定义**：

```python
@app.get("/api/topology/filter-options")
async def get_filter_options():
    """获取筛选选项（设备类型、连接类型等）"""
    return {
        "device_types": STANDARD_DEVICE_TYPES,
        "connection_types": ["交流", "直流"],  # 电流类型
        "cable_types": ["交流", "直流"],  # 电流类型
        "stations": await get_unique_stations()
    }
```

#### 3. 更新算法中的设备类型判断

**修正设备类型判断函数**：

```python
def is_power_source_type(device_type: str) -> bool:
    """判断是否为电源类设备"""
    power_source_types = [
        "发电机组", "直流系统设备", "交直流配电设备", "交流UPS主机", 
        "高压配电设备", "太阳能光伏组件"
    ]
    return device_type in power_source_types

def is_storage_type(device_type: str) -> bool:
    """判断是否为储能类设备"""
    storage_types = [
        "油机启动电池", "-48V直流系统2V阀控铅酸蓄电池", 
        "UPS系统阀控式铅酸蓄电池", "操作电源2V6V12V阀控式铅酸蓄电池"
    ]
    return device_type in storage_types
```

### 数据一致性保障措施

#### 1. 数据验证规则

- Excel导入时验证设备类型是否在标准列表中
- 连接类型字段值验证
- 提供数据清洗和标准化功能

#### 2. 用户界面改进

- 设备管理界面提供设备类型下拉选择
- 连接管理界面区分连接方式和电流类型
- 筛选界面使用统一的选项列表

#### 3. 文档更新

- 更新所有设计文档中的设备类型定义
- 明确各个连接相关字段的用途和取值范围
- 提供用户填表指南

### 向后兼容性

- 保持现有数据库结构不变
- 通过数据迁移脚本统一现有数据
- 渐进式更新，不影响现有功能

### 总结

通过统一设备类型定义和明确连接类型字段用途，确保：

1. **数据一致性**：所有模块使用统一的设备类型和连接类型定义
2. **用户友好**：提供标准化的选项列表，减少用户填表错误
3. **系统稳定**：保持向后兼容，不影响现有功能
4. **易于维护**：清晰的字段定义和用途说明，便于后续开发和维护