# 总线式端口拓扑图数据结构设计

## 概述

本文档定义了总线式端口拓扑图的数据结构，包括总线节点和端口节点的详细设计。该设计基于现有的vis.js图形库，扩展了当前端口级拓扑图的功能。

## 当前系统分析

### 现有端口节点结构
```python
# 当前端口节点数据结构（来自_create_port_nodes函数）
port_node = {
    'id': f"{device_id}_{port_name}",  # 设备ID_端口名称
    'label': port_name,                # 端口名称（如"熔断器1"、"断路器A"）
    'title': f"{device_name} - {port_name}",  # 悬停提示信息
    'device_id': device_id,            # 所属设备ID
    'device_name': device_name,        # 所属设备名称
    'device_type': device_type,        # 设备类型
    'port_type': port_type             # 端口类型（熔断器/断路器）
}
```

### 现有连接边结构
```python
# 当前连接边数据结构（来自_create_port_edges函数）
port_edge = {
    'from': f"{source_device_id}_{source_port}",  # 源端口节点ID
    'to': f"{target_device_id}_{target_port}",    # 目标端口节点ID
    'arrows': 'to',                               # 箭头方向
    'label': connection_type,                     # 连接类型标签
    'connection_id': connection_id                # 连接ID
}
```

## 总线式数据结构设计

### 1. 总线节点（Bus Node）数据结构

总线节点代表按电流方向分组的端口集合，作为视觉上的"总线"。

```python
bus_node = {
    # 基础标识信息
    'id': f"bus_{device_id}_{direction}",     # 总线节点唯一ID
    'type': 'bus',                            # 节点类型标识
    'label': f"{direction}侧总线",             # 显示标签
    'title': f"{device_name} {direction}侧端口总线",  # 悬停提示
    
    # 设备关联信息
    'device_id': device_id,                   # 所属设备ID
    'device_name': device_name,               # 所属设备名称
    'device_type': device_type,               # 设备类型
    
    # 总线特有属性
    'direction': direction,                   # 电流方向（'input'/'output'/'bidirectional'）
    'port_count': port_count,                 # 包含的端口数量
    'port_list': [port_names],                # 包含的端口名称列表
    
    # 视觉样式属性
    'shape': 'box',                          # 节点形状（矩形总线）
    'color': {
        'background': '#E8F4FD',             # 浅蓝色背景
        'border': '#2196F3',                 # 蓝色边框
        'highlight': {
            'background': '#BBDEFB',
            'border': '#1976D2'
        }
    },
    'font': {
        'size': 14,
        'color': '#1565C0',
        'face': 'Arial'
    },
    'margin': 10,                            # 内边距
    'widthConstraint': {'minimum': 120, 'maximum': 200},
    'heightConstraint': {'minimum': 40, 'maximum': 80}
}
```

### 2. 端口节点（Port Node）数据结构

端口节点代表具体的物理端口，连接到对应的总线节点。

```python
port_node = {
    # 基础标识信息
    'id': f"port_{device_id}_{port_name}",   # 端口节点唯一ID
    'type': 'port',                          # 节点类型标识
    'label': port_name,                      # 端口名称
    'title': f"{device_name} - {port_name}\n类型: {port_type}\n状态: {port_status}",
    
    # 设备关联信息
    'device_id': device_id,                  # 所属设备ID
    'device_name': device_name,              # 所属设备名称
    'device_type': device_type,              # 设备类型
    
    # 端口特有属性
    'port_name': port_name,                  # 端口名称
    'port_type': port_type,                  # 端口类型（熔断器/断路器）
    'port_status': port_status,              # 端口状态（正常/故障/维护）
    'direction': direction,                  # 电流方向
    'parent_bus': f"bus_{device_id}_{direction}",  # 所属总线节点ID
    
    # 连接信息
    'connections': [connection_ids],         # 相关连接ID列表
    'connected_ports': [connected_port_ids], # 连接的其他端口ID列表
    
    # 视觉样式属性
    'shape': 'circle',                       # 圆形端口
    'size': 25,                             # 节点大小
    'color': {
        'background': get_port_color(port_type, port_status),
        'border': '#424242',
        'highlight': {
            'background': get_port_highlight_color(port_type, port_status),
            'border': '#212121'
        }
    },
    'font': {
        'size': 10,
        'color': '#212121'
    }
}
```

### 3. 连接边数据结构

#### 3.1 总线到端口连接（Bus-to-Port Edge）
```python
bus_port_edge = {
    'id': f"bus_port_{bus_id}_{port_id}",    # 连接边唯一ID
    'type': 'bus_connection',                # 连接类型
    'from': bus_id,                          # 总线节点ID
    'to': port_id,                           # 端口节点ID
    'arrows': 'none',                        # 无箭头（表示归属关系）
    'color': {
        'color': '#90A4AE',                  # 灰色连线
        'width': 2,
        'dashes': [5, 5]                     # 虚线样式
    },
    'smooth': {
        'enabled': True,
        'type': 'curvedCW',                  # 弯曲连线
        'roundness': 0.2
    },
    'length': 50                             # 连线长度
}
```

#### 3.2 端口到端口连接（Port-to-Port Edge）
```python
port_port_edge = {
    'id': f"port_conn_{connection_id}",      # 连接边唯一ID
    'type': 'port_connection',               # 连接类型
    'from': source_port_id,                  # 源端口节点ID
    'to': target_port_id,                    # 目标端口节点ID
    'arrows': 'to',                          # 箭头指向目标
    'label': connection_type,                # 连接类型标签
    
    # 连接信息
    'connection_id': connection_id,          # 原始连接ID
    'connection_type': connection_type,      # 连接类型
    'voltage_level': voltage_level,          # 电压等级
    'current_capacity': current_capacity,    # 电流容量
    
    # 视觉样式
    'color': {
        'color': get_connection_color(connection_type),
        'width': get_connection_width(voltage_level),
        'highlight': get_connection_highlight_color(connection_type)
    },
    'smooth': {
        'enabled': True,
        'type': 'dynamic'
    }
}
```

## 4. 辅助函数定义

### 4.1 端口颜色映射函数
```python
def get_port_color(port_type, port_status):
    """根据端口类型和状态获取颜色"""
    base_colors = {
        '熔断器': '#FF9800',    # 橙色
        '断路器': '#4CAF50',    # 绿色
        '接触器': '#2196F3',    # 蓝色
        '开关': '#9C27B0'       # 紫色
    }
    
    status_modifiers = {
        '正常': 1.0,
        '故障': 0.5,           # 变暗表示故障
        '维护': 0.7            # 稍微变暗表示维护
    }
    
    base_color = base_colors.get(port_type, '#757575')
    modifier = status_modifiers.get(port_status, 1.0)
    
    return adjust_color_brightness(base_color, modifier)

def get_connection_color(connection_type):
    """根据连接类型获取连线颜色"""
    colors = {
        '电力连接': '#F44336',    # 红色
        '控制连接': '#2196F3',    # 蓝色
        '通信连接': '#4CAF50',    # 绿色
        '接地连接': '#795548'     # 棕色
    }
    return colors.get(connection_type, '#424242')

def get_connection_width(voltage_level):
    """根据电压等级获取连线宽度"""
    if voltage_level >= 10000:      # 高压
        return 4
    elif voltage_level >= 1000:     # 中压
        return 3
    else:                           # 低压
        return 2
```

### 4.2 电流方向判断函数
```python
def determine_port_direction(device_type, port_name, connections):
    """判断端口的电流方向"""
    # 基于设备类型的默认规则
    device_rules = {
        '发电机组': {'output': ['输出', '发电', 'OUT'], 'input': ['输入', '励磁', 'IN']},
        'UPS': {'input': ['输入', 'INPUT', 'AC_IN'], 'output': ['输出', 'OUTPUT', 'AC_OUT']},
        '变压器': {'input': ['一次', 'PRIMARY', '高压'], 'output': ['二次', 'SECONDARY', '低压']},
        '配电柜': {'input': ['进线', 'INPUT'], 'output': ['出线', 'OUTPUT', '馈线']}
    }
    
    # 检查端口名称中的关键词
    rules = device_rules.get(device_type, {})
    
    for direction, keywords in rules.items():
        if any(keyword in port_name for keyword in keywords):
            return direction
    
    # 基于连接关系分析
    if connections:
        # 分析连接的上下游关系
        # 这里需要结合具体的连接数据进行判断
        pass
    
    # 默认为双向
    return 'bidirectional'
```

## 5. 数据转换流程

### 5.1 从现有数据生成总线式结构
```python
def convert_to_bus_topology(devices, connections):
    """将现有设备和连接数据转换为总线式拓扑结构"""
    bus_nodes = []
    port_nodes = []
    bus_port_edges = []
    port_port_edges = []
    
    for device in devices:
        # 1. 分析设备的所有端口
        device_ports = extract_device_ports(device, connections)
        
        # 2. 按电流方向分组端口
        port_groups = group_ports_by_direction(device_ports)
        
        # 3. 为每个方向创建总线节点
        for direction, ports in port_groups.items():
            if ports:  # 只有当该方向有端口时才创建总线
                bus_node = create_bus_node(device, direction, ports)
                bus_nodes.append(bus_node)
                
                # 4. 创建端口节点并连接到总线
                for port in ports:
                    port_node = create_port_node(device, port, direction)
                    port_nodes.append(port_node)
                    
                    # 创建总线到端口的连接
                    bus_port_edge = create_bus_port_edge(bus_node['id'], port_node['id'])
                    bus_port_edges.append(bus_port_edge)
        
        # 5. 创建端口间的连接
        device_connections = get_device_connections(device['id'], connections)
        for conn in device_connections:
            port_edge = create_port_port_edge(conn)
            port_port_edges.append(port_edge)
    
    return {
        'bus_nodes': bus_nodes,
        'port_nodes': port_nodes,
        'bus_port_edges': bus_port_edges,
        'port_port_edges': port_port_edges
    }
```

## 6. API接口扩展

### 6.1 新增API参数
```python
# 在现有的get_graph_data函数中新增参数
def get_graph_data(level='device', layout_type='standard', **filters):
    """
    获取拓扑图数据
    
    Args:
        level: 显示级别 ('device'/'port')
        layout_type: 布局类型 ('standard'/'bus') - 新增参数
        **filters: 其他筛选条件
    """
    if level == 'port' and layout_type == 'bus':
        return get_bus_topology_data(**filters)
    elif level == 'port':
        return get_standard_port_topology_data(**filters)
    else:
        return get_device_topology_data(**filters)
```

### 6.2 总线拓扑数据API
```python
def get_bus_topology_data(**filters):
    """获取总线式端口拓扑数据"""
    # 获取筛选后的设备和连接
    devices = get_filtered_devices(**filters)
    connections = get_filtered_connections(**filters)
    
    # 转换为总线式结构
    bus_data = convert_to_bus_topology(devices, connections)
    
    # 合并所有节点和边
    all_nodes = bus_data['bus_nodes'] + bus_data['port_nodes']
    all_edges = bus_data['bus_port_edges'] + bus_data['port_port_edges']
    
    return {
        'nodes': all_nodes,
        'edges': all_edges,
        'layout_type': 'bus',
        'metadata': {
            'bus_count': len(bus_data['bus_nodes']),
            'port_count': len(bus_data['port_nodes']),
            'connection_count': len(bus_data['port_port_edges'])
        }
    }
```

## 7. 前端集成考虑

### 7.1 vis.js配置调整
```javascript
// 总线式布局的特殊配置
const busLayoutOptions = {
    layout: {
        hierarchical: {
            enabled: true,
            direction: 'LR',        // 左右布局
            sortMethod: 'directed',
            levelSeparation: 200,   // 层级间距
            nodeSpacing: 150,       // 节点间距
            treeSpacing: 200        // 树间距
        }
    },
    physics: {
        enabled: false          // 禁用物理引擎，使用固定布局
    },
    nodes: {
        // 总线节点和端口节点的差异化样式
        chosen: {
            node: function(values, id, selected, hovering) {
                if (id.startsWith('bus_')) {
                    values.borderWidth = 3;
                    values.borderColor = '#1976D2';
                } else if (id.startsWith('port_')) {
                    values.borderWidth = 2;
                    values.size = 30;
                }
            }
        }
    }
};
```

### 7.2 交互功能扩展
```javascript
// 总线节点点击事件
network.on('click', function(params) {
    if (params.nodes.length > 0) {
        const nodeId = params.nodes[0];
        const nodeData = nodes.get(nodeId);
        
        if (nodeData.type === 'bus') {
            // 高亮显示总线下的所有端口
            highlightBusPorts(nodeId);
        } else if (nodeData.type === 'port') {
            // 显示端口详细信息
            showPortDetails(nodeData);
        }
    }
});

// 总线悬停效果
network.on('hoverNode', function(params) {
    const nodeData = nodes.get(params.node);
    if (nodeData.type === 'bus') {
        // 临时高亮总线相关的端口和连接
        highlightBusElements(params.node);
    }
});
```

## 8. 性能优化考虑

### 8.1 数据缓存策略
- 总线结构计算结果缓存
- 按设备类型分组缓存
- 增量更新机制

### 8.2 渲染优化
- 大型网络的分页显示
- 节点聚合显示
- 按需加载端口详情

## 9. 扩展性设计

### 9.1 自定义总线规则
- 支持用户自定义端口分组规则
- 可配置的总线样式
- 动态总线生成算法

### 9.2 多层级总线
- 支持总线的嵌套结构
- 子总线和父总线的关系
- 跨设备总线连接

---

**文档版本**: 1.0  
**创建日期**: 2024年1月  
**最后更新**: 2024年1月  
**作者**: 系统开发团队